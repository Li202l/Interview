# 1.goLang垃圾回收机制

垃圾回收就是对程序中不再使用的内存资源进行自动回收操作

## 1.1常见的垃圾回收算法

### 1.1.1引用计数

每个对象维护一个引用计数，当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1 ，当计数为 0 时，回收该对象。

优点：对象可以很快被回收，不会出现内存耗尽或到达阀值才回收。

缺点：不能很好的处理循环引用

------



### 1.1.2.标记-清除

从根变量开始遍历所有引用的对象，引用的对象标记被引用，没有被标记的则进行回收

###  v1.3之前的标记-清除:

1.暂停业务逻辑，找到不可达对象和可达对象

2.标记出所有被可达对象

3.标记完了以后，清除所有没有被标记的对象

4.停止暂停，继续运行程序，重复这个过程

优点：解决了引用计数的缺点

缺点：需要STW stop the world 暂时停止程序运行

------



###  v1.5三色标记法:

1.新创建的对象都标记为默认的白色

2.每次GC开始回收，从根节点开始遍历所有对象，把遍历到的对象从白色集合放入灰色集合

3.遍历灰色集合，将灰色对象引用的对象也从白色集合放入灰色集合中，然后将遍历过的灰色对象放入黑色集合

4.循环这个步骤，直到所有灰色集合中的对象都放入黑色集合

5.回收所有白色标记的对象，回收垃圾也就是

三色标记法在不采用STW保护时会出现

一个黑色对象新增了一个对一个白色对象的引用，而且这个白色对象只被这一个黑色对象引用，没有其他黑色或灰色对象引用

1.黑色对象已经扫描完毕，没有扫描到新增的引用

2.没有其他灰色对象引用该白色对象

如果同时出现这两种现象，对象会丢失

解决方案:

1.强三色不变式：强制性的不允许黑色对象引用白色对象，破坏第一种    情况

2.弱三色不变式：黑色对象可以引用白色对象，但白色对象要求被其他灰色对象间接的引用

屏障：

1.插入屏障：A对象引用B对象的时候，B对象被标记为灰色 强三色不变式

只有堆上的对象触发插入屏障，栈上的对象不触发插入屏障，在准备回收白色前，重新扫描一遍栈空间，加入STW，防止外界干扰，这个操作的不足之处是结束时需要STW重新扫描栈

2.删除屏障：被删除的对象，如果是灰色或者白色，那么标记为灰色 弱三色不变式，不足之处在于回收精度低，一个对象即使被删除了最后一个指向它的指针依据可以活过这一轮，在下一轮垃圾回收时才被清理掉

------

###  v1.8三色标记法 + 混合写屏障机制:

1.垃圾回收开始将所有栈上的对象全部扫描并标记成黑色 之后无需二次扫描，无需STW

2.垃圾回收期间，任何栈上创建的新对象，均为黑色

3.被删除对象标记为灰色

4.被添加的对象标记为白色

满足变形的弱三色不变式

------

# 2.GPM调度和CSP模型

## 2.1CSP模型

CSP模型通过通信的方式来共享内存，不同于传统的多线程通过共享内存来通信。用于描述两个独立的并发实体通过共享的通讯channel来进行通信的并发模型

## 2.2GPM模型